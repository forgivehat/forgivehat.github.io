<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"forgivehat.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="最小(大)值最大(小)化问题875.爱吃香蕉的珂珂">
<meta property="og:type" content="article">
<meta property="og:title" content="二分题汇总">
<meta property="og:url" content="https://forgivehat.github.io/2023/04/04/%E4%BA%8C%E5%88%86%E9%A2%98%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Nathanaël">
<meta property="og:description" content="最小(大)值最大(小)化问题875.爱吃香蕉的珂珂">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-04T04:02:05.000Z">
<meta property="article:modified_time" content="2023-04-04T04:04:20.241Z">
<meta property="article:author" content="Nathanaël">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://forgivehat.github.io/2023/04/04/%E4%BA%8C%E5%88%86%E9%A2%98%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>二分题汇总 | Nathanaël</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nathanaël</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">纳塔纳埃尔，切莫去尝试旧日的清水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://forgivehat.github.io/2023/04/04/%E4%BA%8C%E5%88%86%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="Nathanaël">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nathanaël">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二分题汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-04-04 12:02:05 / 修改时间：12:04:20" itemprop="dateCreated datePublished" datetime="2023-04-04T12:02:05+08:00">2023-04-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="最小-大-值最大-小-化问题"><a href="#最小-大-值最大-小-化问题" class="headerlink" title="最小(大)值最大(小)化问题"></a>最小(大)值最大(小)化问题</h3><h4 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875.爱吃香蕉的珂珂"></a>875.爱吃香蕉的珂珂</h4><span id="more"></span>

<blockquote>
<p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入: piles &#x3D; [3,6,7,11], h &#x3D; 8<br>输出: 4</p>
</blockquote>
<p>速度越快，吃完所以香蕉的时间就越短。假如存在一个速度k，使得珂珂可以在h小时的时候正好吃完所有香蕉，那么如果这个速度稍大，则肯定也能在h小时内吃完所有香蕉；如果这个速度稍小，则一定不能在h小时内吃完所以香蕉。因此这个速度左右两边具有二段性，可以用二分猜答案</p>
<p>对于每次二分的中点mid，即选定的速度k，计算吃完所有香蕉的时间cnt，如果cnt &gt; h，说明这个速度太小以至于无法在h小时内吃完所以香蕉，因此需要将二分左边界调整为k + 1，因为速度为k无法满足h小时内吃完香蕉的要求</p>
<blockquote>
<p>向上取整小技巧：(piles[i] + k - 1) &#x2F; k</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(piles.<span class="built_in">begin</span>(), piles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> k) &#123;</span><br><span class="line">            <span class="type">int</span> hour = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">              hour += (piles[i] + k - <span class="number">1</span>) / k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hour &gt; h; </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果在k速度下吃完香蕉的时间大于h，则至少需要k + 1的速度</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1870-准时到达的列车最小时速"><a href="#1870-准时到达的列车最小时速" class="headerlink" title="1870.准时到达的列车最小时速"></a>1870.准时到达的列车最小时速</h4><blockquote>
<p>给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。</p>
<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>
<p>例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。<br>返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。</p>
<p>生成的测试用例保证答案不超过 1e7 ，且 hour 的 小数点后最多存在两位数字 。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：dist &#x3D; [1,3,2], hour &#x3D; 6<br>输出：1<br>解释：速度为 1 时：</p>
<ul>
<li>第 1 趟列车运行需要 1&#x2F;1 &#x3D; 1 小时。</li>
<li>由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3&#x2F;1 &#x3D; 3 小时。</li>
<li>由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2&#x2F;1 &#x3D; 2 小时。</li>
<li>你将会恰好在第 6 小时到达。</li>
</ul>
</blockquote>
<p>速度越快，所需时间越短。假设存在速度speed，恰好能在hour小时到达目的地，那么当速度小于speed时，无法到达目的地，当速度大于等于speed时，一定能到达目的地，speed两端具有二段性质，可以二分</p>
<p>由于dist长度、dist[i]、hour都至少为1，所以二分的下界L为1，题目里提示测试样例答案不超过1e7，因此上界R应当设为1e7 + 1，当二分结束时若上下界为1e7 + 1，说明永远也到不了目的地</p>
<p>对于每次中点值，即猜测的速度，遍历数组统计所需时间，需要主要前n-1个车站可能需要等待，因此时间需要向上取整，最后一个车站不需要等待，直接加上即可。最后判断所需时间与hour的大小关系以调整左右边界</p>
<blockquote>
<p>向上取整小技巧： (dist[i] + v - 1) &#x2F; v</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSpeedOnTime</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, <span class="type">double</span> hour)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e7</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> v) &#123;</span><br><span class="line">            <span class="type">double</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                tot += (dist[i] + v - <span class="number">1</span>) / v;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += (<span class="type">double</span>) dist[n - <span class="number">1</span>] / v;</span><br><span class="line">            <span class="keyword">return</span> tot &lt;= hour;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="number">1e7</span> + <span class="number">1</span> ? <span class="number">-1</span> : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2187-完成旅途的最少时间"><a href="#2187-完成旅途的最少时间" class="headerlink" title="2187.完成旅途的最少时间"></a>2187.完成旅途的最少时间</h4><blockquote>
<p>给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。</p>
<p>每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。</p>
<p>给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：time &#x3D; [1,2,3], totalTrips &#x3D; 5<br>输出：3<br>解释：</p>
<ul>
<li>时刻 t &#x3D; 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。<br>已完成的总旅途数为 1 + 0 + 0 &#x3D; 1 。</li>
<li>时刻 t &#x3D; 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。<br>已完成的总旅途数为 2 + 1 + 0 &#x3D; 3 。</li>
<li>时刻 t &#x3D; 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。<br>已完成的总旅途数为 3 + 1 + 1 &#x3D; 5 。<br>所以总共完成至少 5 趟旅途的最少时间为 3 。</li>
</ul>
</blockquote>
<p>时间越长，能完成的旅行次数就越多，设最终求得的时间为t，此时恰好能完成totalTrips次旅行，则t + 1的时间内一定至少能成totalTrips次旅行，而t - 1的时间时间内肯定无法完成totalTrips次旅行，具有二段性，可以二分求解</p>
<p>下界为1，上界为跑一趟用时最短的车的时长<strong>time[i] * totalTrips</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTime</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; time, <span class="type">int</span> totalTrips)</span> </span>&#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最长的时间最多是用最快的那一辆车跑totalTrips趟</span></span><br><span class="line">        r = (ll) totalTrips * *<span class="built_in">min_element</span>(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = time.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](ll x) &#123;</span><br><span class="line">            ll tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                tot += x / time[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tot &gt;= totalTrips;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2226-每个小孩最多能分到多少糖果"><a href="#2226-每个小孩最多能分到多少糖果" class="headerlink" title="2226.每个小孩最多能分到多少糖果"></a>2226.每个小孩最多能分到多少糖果</h4><blockquote>
<p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。</p>
<p>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。</p>
<p>返回每个小孩可以拿走的 最大糖果数目 。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：candies &#x3D; [5,8,6], k &#x3D; 3<br>输出：5<br>解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。</p>
<p>示例 2：</p>
<p>输入：candies &#x3D; [2,5], k &#x3D; 11<br>输出：0<br>解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。</p>
</blockquote>
<p>假设每个小孩恰好能拿到x颗，那么一定能拿到x - 1颗，但不一定能拿到 x + 1颗</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCandies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candies, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = *<span class="built_in">max_element</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            ll cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : candies) &#123;</span><br><span class="line">                cnt += c / x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r  + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2439-最小化数组最大值"><a href="#2439-最小化数组最大值" class="headerlink" title="2439.最小化数组最大值"></a>2439.最小化数组最大值</h4><blockquote>
<p>给你一个下标从 0 开始的数组 nums ，它含有 n 个非负整数。</p>
<p>每一步操作中，你需要：</p>
<p>选择一个满足 1 &lt;&#x3D; i &lt; n 的整数 i ，且 nums[i] &gt; 0 。<br>将 nums[i] 减 1 。<br>将 nums[i - 1] 加 1 。<br>你可以对数组执行 任意 次上述操作，请你返回可以得到的 nums 数组中 最大值 最小 为多少。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,7,1,6]<br>输出：5<br>解释：<br>一串最优操作是：</p>
<ol>
<li>选择 i &#x3D; 1 ，nums 变为 [4,6,1,6] 。</li>
<li>选择 i &#x3D; 3 ，nums 变为 [4,6,2,5] 。</li>
<li>选择 i &#x3D; 1 ，nums 变为 [5,5,2,5] 。<br>nums 中最大值为 5 。无法得到比 5 更小的最大值。<br>所以我们返回 5 。</li>
</ol>
</blockquote>
<p>最大化最小值，一眼二分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeArrayValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">long</span> del = <span class="number">0</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">tmp</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[i] &gt; x) &#123;</span><br><span class="line">                    del = tmp[i] - x;</span><br><span class="line">                    tmp[i] = x;</span><br><span class="line">                    tmp[i - <span class="number">1</span>] += del;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp[<span class="number">0</span>] &lt;= x;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2498-青蛙过河II"><a href="#2498-青蛙过河II" class="headerlink" title="2498.青蛙过河II"></a>2498.青蛙过河II</h4><blockquote>
<p>给你一个下标从 0 开始的整数数组 stones ，数组中的元素 严格递增 ，表示一条河中石头的位置。</p>
<p>一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 至多 到达 一次。</p>
<p>一次跳跃的 长度 是青蛙跳跃前和跳跃后所在两块石头之间的距离。</p>
<p>更正式的，如果青蛙从 stones[i] 跳到 stones[j] ，跳跃的长度为 |stones[i] - stones[j]| 。<br>一条路径的 代价 是这条路径里的 最大跳跃长度 。</p>
<p>请你返回这只青蛙的 最小代价 。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：stones &#x3D; [0,2,5,6,7]<br>输出：5<br>解释：上图展示了一条最优路径。<br>这条路径的代价是 5 ，是这条路径中的最大跳跃长度。<br>无法得到一条代价小于 5 的路径，我们返回 5 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = stones[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n - <span class="number">4</span>; i += <span class="number">2</span>) <span class="keyword">if</span>(stones[i] + x &lt; stones[i + <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(stones[n - <span class="number">2</span>] + x &lt; stones[n - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">3</span>; i -= <span class="number">2</span>) <span class="keyword">if</span>(stones[i] &gt; stones[i - <span class="number">2</span>] + x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(stones[<span class="number">1</span>] &gt; stones[<span class="number">0</span>] + x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n - <span class="number">3</span>; i += <span class="number">2</span>) <span class="keyword">if</span>(stones[i] + x &lt; stones[i + <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(stones[n - <span class="number">1</span>] &gt; stones[n - <span class="number">2</span>] + x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">3</span>; i -= <span class="number">2</span>) <span class="keyword">if</span>(stones[i] &gt; stones[i - <span class="number">2</span>] + x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(stones[<span class="number">1</span>] &gt; stones[<span class="number">0</span>] + x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2513-最小化两个数组中的最大值"><a href="#2513-最小化两个数组中的最大值" class="headerlink" title="2513.最小化两个数组中的最大值"></a>2513.最小化两个数组中的最大值</h4><blockquote>
<p>给你两个数组 arr1 和 arr2 ，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：</p>
<p>arr1 包含 uniqueCnt1 个 互不相同 的正整数，每个整数都 不能 被 divisor1 整除 。<br>arr2 包含 uniqueCnt2 个 互不相同 的正整数，每个整数都 不能 被 divisor2 整除 。<br>arr1 和 arr2 中的元素 互不相同 。<br>给你 divisor1 ，divisor2 ，uniqueCnt1 和 uniqueCnt2 ，请你返回两个数组中 最大元素 的 最小值 。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：divisor1 &#x3D; 2, divisor2 &#x3D; 7, uniqueCnt1 &#x3D; 1, uniqueCnt2 &#x3D; 3<br>输出：4<br>解释：<br>我们可以把前 4 个自然数划分到 arr1 和 arr2 中。<br>arr1 &#x3D; [1] 和 arr2 &#x3D; [2,3,4] 。<br>可以看出两个数组都满足条件。<br>最大值是 4 ，所以返回 4</p>
</blockquote>
<p>最大化最小值，想到二分</p>
<p>猜测一个数x恰好满足条件，即至少有uniqueCnt1个数满足不能被d1整除，以及至少有uniqueCnt2个数不能被d2整除，当猜测的这个数为x + 1时，显然满足条件，当这个数为x - 1时，则无法满足条件，可以根据这个性质进行二分搜索结果</p>
<p>    根据题意可以讲所有数分为四类</p>
<ol>
<li><p>不能被d1整除，也不能被d2整除</p>
</li>
<li><p>不能被d1整除，但能被d2整除</p>
</li>
<li><p>能被d1整除，但不能被d2整除</p>
</li>
<li><p>既能被d1整除，也能被d2整除</p>
</li>
</ol>
<p>为了使数的范围尽量小，应该优先使用2、3的数去填补差额，最后实在不足了采用1中的数去补充（通用的是最贵的</p>
<p>根据容斥原理</p>
<blockquote>
<p>不能被d1且不能被d2整除的数的数量：</p>
<p>    v &#x3D; x - 能被d1整除的数量 - 能被d2整除的数量 + 能被lcm(d1,d2)整除的数的数量</p>
<p>不能被d1整除的数量：</p>
<p>    a &#x3D; x - x &#x2F; d1</p>
<p>不能被d2整除的数量：</p>
<p>    b &#x3D; x - x &#x2F; d2</p>
</blockquote>
<p>因此有 a - v个数不能被d1整除但能被d2整除，这些数必定分在分组1，同理，b - v个数必然分在分组2</p>
<p>不能被d1也不能被d2整除的数可以分在两个分组中的任一个</p>
<p>我们优先使用只能被d1或d2整除的数去填满分组1或分组2，最后用通用的那v个数去填补可能存在的空缺</p>
<p>因此只需要判断 v &gt;&#x3D; max(uniqueCnt1 - (a - v), 0) + max(uniqueCnt2 - (b - v), 0)是否成立</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeSet</span><span class="params">(<span class="type">int</span> divisor1, <span class="type">int</span> divisor2, <span class="type">int</span> uniqueCnt1, <span class="type">int</span> uniqueCnt2)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span>  l = <span class="number">1</span>, r = (uniqueCnt1 + uniqueCnt2) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> LCM = <span class="built_in">lcm</span>(divisor1, divisor2);</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">long</span> p1 =  x / divisor1;</span><br><span class="line">            <span class="type">long</span> p2 = x / divisor2;</span><br><span class="line">            <span class="type">long</span> p3 = x / LCM;</span><br><span class="line">            <span class="type">long</span> v = x - p1 - p2 + p3;   <span class="comment">// 既不能被d1也不能被d2整除的数的个数</span></span><br><span class="line">            <span class="type">long</span> a = x - p1, b = x - p2; <span class="comment">// 分别为不能被d1、d2整除的数的个数</span></span><br><span class="line">            <span class="keyword">return</span> v &gt;= <span class="built_in">max</span>(uniqueCnt1 - (a - v), <span class="number">0l</span>) + <span class="built_in">max</span>(uniqueCnt2 - (b - v), <span class="number">0l</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">long</span>  mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a;</span><br><span class="line">        a = b % a;</span><br><span class="line">        b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2517-礼盒的最大甜蜜度"><a href="#2517-礼盒的最大甜蜜度" class="headerlink" title="2517.礼盒的最大甜蜜度"></a>2517.礼盒的最大甜蜜度</h4><blockquote>
<p>给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。</p>
<p>商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。</p>
<p>返回礼盒的 最大 甜蜜度。</p>
</blockquote>
<blockquote>
<p>示例 ：</p>
<p> 输入：price &#x3D; [13,5,1,8,21,2], k &#x3D; 3<br> 输出：8<br> 解释：选出价格分别为 [13,5,21] 的三类糖果。<br> 礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) &#x3D; min(8, 8, 16) &#x3D; 8 。<br> 可以证明能够取得的最大甜蜜度就是 8</p>
</blockquote>
<p>本题和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/magnetic-force-between-two-balls/">1552.两球之间的磁力</a>完全相同</p>
<p>一个序列中两个绝对值之差的最小值就是把这个序列排序后相邻元素之差的最小值。</p>
<p>这个差值最小为0，最大为price[n - 1]，对这个区间进行二分，对于区间中点mid，如果k个数中的任意两个数，都满足差值 &gt;&#x3D; mid，那么就可能存在一个比mid要大的数T，满足任意两个数的差值都 &gt;&#x3D; T，存在二段性质。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> lim) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(price[i] - price[j] &gt;= lim) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    j = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = price[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) &#123; </span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2528-最大化城市的最小供电站数目"><a href="#2528-最大化城市的最小供电站数目" class="headerlink" title="2528.最大化城市的最小供电站数目"></a>2528.最大化城市的最小供电站数目</h4><blockquote>
<p>给你一个下标从 0 开始长度为 n 的整数数组 stations ，其中 stations[i] 表示第 i 座城市的供电站数目。</p>
<p>每个供电站可以在一定 范围 内给所有城市提供电力。换句话说，如果给定的范围是 r ，在城市 i 处的供电站可以给所有满足 |i - j| &lt;&#x3D; r 且 0 &lt;&#x3D; i, j &lt;&#x3D; n - 1 的城市 j 供电。</p>
<p>|x| 表示 x 的 绝对值 。比方说，|7 - 5| &#x3D; 2 ，|3 - 10| &#x3D; 7 。<br>一座城市的 电量 是所有能给它供电的供电站数目。</p>
<p>政府批准了可以额外建造 k 座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。</p>
<p>给你两个整数 r 和 k ，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。</p>
<p>这 k 座供电站可以建在多个城市。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：stations &#x3D; [1,2,4,5,0], r &#x3D; 1, k &#x3D; 2<br>输出：5<br>解释：<br>最优方案之一是把 2 座供电站都建在城市 1 。<br>每座城市的供电站数目分别为 [1,4,4,5,0] 。</p>
<ul>
<li>城市 0 的供电站数目为 1 + 4 &#x3D; 5 。</li>
<li>城市 1 的供电站数目为 1 + 4 + 4 &#x3D; 9 。</li>
<li>城市 2 的供电站数目为 4 + 4 + 5 &#x3D; 13 。</li>
<li>城市 3 的供电站数目为 5 + 4 &#x3D; 9 。</li>
<li>城市 4 的供电站数目为 5 + 0 &#x3D; 5 。<br>供电站数目最少是 5 。<br>无法得到更优解，所以我们返回 5 。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxPower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stations, <span class="type">int</span> R, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">long</span> <span class="type">long</span> lim) &#123;</span><br><span class="line">            vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> s : stations) vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= R &amp;&amp; i &lt; n; i++) sum += vec[i]; <span class="comment">// 计算第一个窗口内供电站数量</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> rest = K;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = R; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; lim) &#123; <span class="comment">// 窗口内的供电站数量不够</span></span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> del = lim - sum;</span><br><span class="line">                    <span class="keyword">if</span>(del &gt; rest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    rest -= del;</span><br><span class="line">                    vec[r] += del;</span><br><span class="line">                    sum += del;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= R) sum -= vec[l], l++;</span><br><span class="line">                <span class="keyword">if</span>(r &lt; n - <span class="number">1</span>) sum += vec[r + <span class="number">1</span>], r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l = <span class="number">0</span>, r = <span class="number">2e10</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2560-打家劫舍-IV"><a href="#2560-打家劫舍-IV" class="headerlink" title="2560.打家劫舍 IV"></a>2560.打家劫舍 IV</h4><blockquote>
<p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p>
<p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。</p>
<p>小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。</p>
<p>给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。</p>
<p>另给你一个整数数组 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。</p>
<p>返回小偷的 最小 窃取能力。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,3,5,9], k &#x3D; 2<br>输出：5<br>解释：<br>小偷窃取至少 2 间房屋，共有 3 种方式：</p>
<ul>
<li>窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) &#x3D; 5 。</li>
<li>窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) &#x3D; 9 。</li>
<li>窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) &#x3D; 9 。<br>因此，返回 min(5, 9, 9) &#x3D; 5 。</li>
</ul>
</blockquote>
<p>假设小偷至少偷k间房屋的最小窃取能力为minCap，则当窃取能力小于minCap时，小偷无法偷够k间房屋，当窃取能力大于等于minCap时，小偷一定能至少偷k间房屋。minCap两端具有二段性，可以用二分猜答案</p>
<p>l、r为区间上、下界，初值分别数组的最小值和最大值，对于每次的mid，遍历数组，看能否满足至少偷窃k间房屋的要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCapability</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = nums[<span class="number">0</span>], r = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            l = <span class="built_in">min</span>(l, x);</span><br><span class="line">            r = <span class="built_in">max</span>(r, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= x &amp;&amp; i - j &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    j = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt &lt; k;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>  r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他二分问题"><a href="#其他二分问题" class="headerlink" title="其他二分问题"></a>其他二分问题</h3><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h4><blockquote>
<p>整数数组 nums 按升序排列，数组中的值互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入: nums &#x3D; [<code>4,5,6,7,0,1,2]</code>, target &#x3D; 0</p>
<p>输出: 4</p>
</blockquote>
<p>旋转后的数组具有二段性，如示例一所示，以0为分界，前面的四个数大于后面的三个数，且分别单调递增，用二分可以找到数组中的最小值，再根据target与末尾元素的大小关系判断它是在哪一段里，最后调整边界，进行二分查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// find the min n&#x27;s index</span></span><br><span class="line">         <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid] &gt; nums.<span class="built_in">back</span>()) l = mid + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target &gt; nums.<span class="built_in">back</span>()) &#123; <span class="comment">// target在前一段</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在后一段</span></span><br><span class="line">        r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[l] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="81-搜索旋转排序数字II"><a href="#81-搜索旋转排序数字II" class="headerlink" title="81.搜索旋转排序数字II"></a>81.搜索旋转排序数字II</h4><blockquote>
<p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], … , nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为[4,5,6,6,7,0,1,2,4,4] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入: nums &#x3D; <code>[2,5,6,0,0,1,2]</code>, target &#x3D; 0</p>
<p>输出: true</p>
</blockquote>
<p>这一题与上一题的差别在于给定数组有重复元素，如果给定数组是从一段重复的元素中间旋转得到的，就不具备二段性了,比如<code>[2,2,2,3,2,2,2]</code> ,需要先进行处理，将后半截的重复元素剔除，再二分得到数组最小值的位置，额外判断一些边际条件后进行二分查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> target == nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[<span class="number">0</span>] == nums[r]) r--;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">               r = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l = mid;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="154-寻找旋转排序数字中的最小值II"><a href="#154-寻找旋转排序数字中的最小值II" class="headerlink" title="154.寻找旋转排序数字中的最小值II"></a>154.寻找旋转排序数字中的最小值II</h4><blockquote>
<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入： nums &#x3D; [1,3,5]</p>
<p>输出：1</p>
</blockquote>
<p>与上题一样，需要先对后半截元素去重，然后再二分，题目只要求二分得到最小值，因此一次二分结束后判断下边际条件就可以返回结果了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[<span class="number">0</span>] == nums[r]) r--;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l + <span class="number">1</span> &lt; n) <span class="keyword">return</span> nums[l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h4><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
</blockquote>
<blockquote>
<p>示例：</p>
<p>输入：nums &#x3D; [1,3,4,2,2]<br>输出：2</p>
</blockquote>
<p>根据容斥原理，在只含有1~n的n+1个数中，至少存在一个数出现了两次</p>
<p>将二分区间设为1~n，L &#x3D; 1, R &#x3D; n，取mid，假设在[L, mid]这个区间内存在的数大于mid - l + 1，说明重复的数一定在[L, mid]区间内，反之则存在于(mid, R]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> mid) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= l &amp;&amp; x &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid) &gt; mid - l + <span class="number">1</span>) </span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="统计公平数对的数目"><a href="#统计公平数对的数目" class="headerlink" title="统计公平数对的数目"></a>统计公平数对的数目</h4><blockquote>
<p>给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。</p>
<p>如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：</p>
<p>0 &lt;&#x3D; i &lt; j &lt; n，且<br>lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper</p>
</blockquote>
<blockquote>
<p>示例</p>
<p>输入：nums &#x3D; [0,1,7,4,4,5], lower &#x3D; 3, upper &#x3D; 6<br>输出：6<br>解释：共计 6 个公平数对：(0,3)、(0,4)、(0,5)、(1,3)、(1,4) 和 (1,5) 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countFairPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 数组递增，</span></span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">findL</span>(nums, <span class="number">0</span>, i, lower - nums[i]);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">findR</span>(nums, <span class="number">0</span>, i, upper - nums[i]); </span><br><span class="line">            res += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    找第一个大于等于lower - nums[i]的数的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findL</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    找第一个大于upper - nums[i]的数的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/26/22%E7%A7%8B%E5%AD%A3%20CMU%2015-445-Project-1/" rel="prev" title="CMU 15-445 Project-1（2022秋季）">
      <i class="fa fa-chevron-left"></i> CMU 15-445 Project-1（2022秋季）
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/08/xv6%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%BB%86%E8%8A%82/" rel="next" title="xv6进程调度细节">
      xv6进程调度细节 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F-%E5%A4%A7-%E5%80%BC%E6%9C%80%E5%A4%A7-%E5%B0%8F-%E5%8C%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">最小(大)值最大(小)化问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="nav-number">1.1.</span> <span class="nav-text">875.爱吃香蕉的珂珂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1870-%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F"><span class="nav-number">1.2.</span> <span class="nav-text">1870.准时到达的列车最小时速</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2187-%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4"><span class="nav-number">1.3.</span> <span class="nav-text">2187.完成旅途的最少时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2226-%E6%AF%8F%E4%B8%AA%E5%B0%8F%E5%AD%A9%E6%9C%80%E5%A4%9A%E8%83%BD%E5%88%86%E5%88%B0%E5%A4%9A%E5%B0%91%E7%B3%96%E6%9E%9C"><span class="nav-number">1.4.</span> <span class="nav-text">2226.每个小孩最多能分到多少糖果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2439-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">1.5.</span> <span class="nav-text">2439.最小化数组最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2498-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3II"><span class="nav-number">1.6.</span> <span class="nav-text">2498.青蛙过河II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2513-%E6%9C%80%E5%B0%8F%E5%8C%96%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">1.7.</span> <span class="nav-text">2513.最小化两个数组中的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2517-%E7%A4%BC%E7%9B%92%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9C%E8%9C%9C%E5%BA%A6"><span class="nav-number">1.8.</span> <span class="nav-text">2517.礼盒的最大甜蜜度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2528-%E6%9C%80%E5%A4%A7%E5%8C%96%E5%9F%8E%E5%B8%82%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BE%9B%E7%94%B5%E7%AB%99%E6%95%B0%E7%9B%AE"><span class="nav-number">1.9.</span> <span class="nav-text">2528.最大化城市的最小供电站数目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2560-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-IV"><span class="nav-number">1.10.</span> <span class="nav-text">2560.打家劫舍 IV</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">其他二分问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">33.搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E5%AD%97II"><span class="nav-number">2.2.</span> <span class="nav-text">81.搜索旋转排序数字II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E5%AD%97%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII"><span class="nav-number">2.3.</span> <span class="nav-text">154.寻找旋转排序数字中的最小值II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text">287. 寻找重复数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-number">2.5.</span> <span class="nav-text">统计公平数对的数目</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Nathanaël"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">Nathanaël</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/forgivehat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;forgivehat" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nathanaël</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
